import { GoogleGenerativeAI } from '@google/generative-ai';
import { AIProvider, AIProviderConfig } from './interface';
import { CodeChanges, TaskContext, LogAnalysis } from '../../types';
import { extractCodeChanges, JsonParsingContext } from './json-parser';

export class GeminiProvider implements AIProvider {
  public name = 'gemini';
  private client: GoogleGenerativeAI;
  private model: any;

  constructor(private config: AIProviderConfig) {
    if (!config.apiKey) {
      throw new Error('Google AI API key is required');
    }
    this.client = new GoogleGenerativeAI(config.apiKey);
    this.model = this.client.getGenerativeModel({ model: config.model });
  }

  async generateCode(prompt: string, context: TaskContext): Promise<CodeChanges> {
    const systemPrompt = `You are an expert software developer. Generate code changes based on the task description.
Include both feature implementation and test code together. Return your response as a JSON object with this structure:
{
  "files": [
    {
      "path": "relative/path/to/file",
      "content": "file content here",
      "operation": "create" | "update" | "delete"
    }
  ],
  "summary": "Brief summary of changes"
}`;

    const userPrompt = `Task: ${context.task.title}
Description: ${context.task.description}

${context.codebaseContext ? `Codebase Context:\n${context.codebaseContext}\n` : ''}

${prompt}`;

    try {
      const result = await this.model.generateContent(`${systemPrompt}\n\n${userPrompt}`);
      const response = result.response;
      const text = response.text();

      // Use shared JSON parser for consistent extraction
      const parsingContext: JsonParsingContext = {
        providerName: 'gemini',
        taskId: context.task.id,
        prdId: context.prdId,
        phaseId: context.phaseId ?? undefined,
      };
      const codeChanges = extractCodeChanges(text, undefined, parsingContext);
      if (codeChanges) {
        return codeChanges;
      }

      // Fallback: create a single file
      return {
        files: [
          {
            path: 'generated-code.ts',
            content: text,
            operation: 'create' as const,
          },
        ],
        summary: 'Code generated by Google Gemini',
      };
    } catch (error) {
      throw new Error(`Gemini API error: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Generate text without expecting JSON CodeChanges format
   * Used for PRD building (schemas, test plans, etc.) where plain text output is expected
   */
  async generateText(prompt: string, options?: { maxTokens?: number; temperature?: number; systemPrompt?: string }): Promise<string> {
    const maxTokens = options?.maxTokens || this.config.maxTokens || 4000;
    const temperature = options?.temperature ?? 0.7;
    const systemPrompt = options?.systemPrompt || '';

    const fullPrompt = systemPrompt ? `${systemPrompt}\n\n${prompt}` : prompt;
    const result = await this.model.generateContent({
      contents: [{ role: 'user', parts: [{ text: fullPrompt }] }],
      generationConfig: { maxOutputTokens: maxTokens, temperature },
    });

    return result.response.text();
  }

  async analyzeError(error: string, context: TaskContext): Promise<LogAnalysis> {
    const prompt = `Analyze this error and provide recommendations. Return JSON:

{
  "errors": ["list of errors"],
  "warnings": ["list of warnings"],
  "summary": "brief summary",
  "recommendations": ["actionable recommendations"]
}

Error:
${error}

Task Context:
${context.task.description}`;

    try {
      const result = await this.model.generateContent(prompt);
      const text = result.response.text();

      const jsonMatch = text.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        try {
          return JSON.parse(jsonMatch[0]) as LogAnalysis;
        } catch {
          // Fallback
        }
      }

      return {
        errors: [error],
        warnings: [],
        summary: 'Error analysis completed',
        recommendations: ['Review the error message and fix the underlying issue'],
      };
    } catch (error) {
      return {
        errors: [error instanceof Error ? error.message : String(error)],
        warnings: [],
        summary: 'Failed to analyze error',
      };
    }
  }
}

